#!/usr/bin/env bash
# ^^^ for syntax checking in the editor only

[ -z "$MDSC_DETAIL" ] || echo "+ DistroImage: library included" >&2

# checks and updates MDSC_PRJ_NAME variable with project in focus
# $3 is empty or 'local' or 'export'
DistroSelectProject(){
	local MDSC_CMD='DistroSelectProject'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	if [ "$1" != "MDSC_PRJ_NAME" ] ; then
		echo "$MDSC_CMD: â›” ERROR: env name required to be MDSC_PRJ_NAME!" >&2
		set +e ; return 1
	fi
	if [ -z "$2" ] ; then
		echo "$MDSC_CMD: â›” ERROR: project name required!" >&2
		set +e ; return 1
	fi
	if [ "$2" = "$MDSC_PRJ_NAME" ] ; then
		[ -z "$MDSC_DETAIL" ] || echo "* $MDSC_CMD: same project ($2)" >&2
		return 0
	fi
	if [ "$2" = "--reset" ] ; then
		if [ -z "$MDSC_PRJ_NAME" ] ; then
			[ -z "$MDSC_DETAIL" ] || echo "* $MDSC_CMD: already clean" >&2
			return 0
		fi
		[ -z "$MDSC_DETAIL" ] || echo "* $MDSC_CMD: reset project (previous selection: $MDSC_PRJ_NAME)" >&2
		export MDSC_PRJ_NAME=
		# export MDSC_PRJ_MPRV=
		# export MDSC_PRJ_BSEQ=
		return 0
	fi
	case "$3" in
		export)
			export MDSC_PRJ_NAME="$2"
			# export MDSC_PRJ_MPRV=
			# export MDSC_PRJ_BSEQ=
			[ -z "$MDSC_DETAIL" ] || echo "* $MDSC_CMD: project selected and exported ($2)" >&2
			return 0
		;;
		'')
			MDSC_PRJ_NAME="$2"
			# MDSC_PRJ_MPRV=
			# MDSC_PRJ_BSEQ=
			[ -z "$MDSC_DETAIL" ] || echo "* $MDSC_CMD: project selected ($2)" >&2
			return 0
		;;
		*)
			echo "$MDSC_CMD: â›” ERROR: invalid extra option: $3" >&2
			set +e ; return 1
		;;
	esac
}

#
#
DistroSshConnect(){
	local MDSC_CMD='DistroSshConnect'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	local useSshHost="${useSshHost:-}" useSshPort="${useSshPort:-}" useSshUser="${useSshUser:-}" useSshHome="${useSshHome:-}" useSshArgs="${useSshArgs:-}"

	while true ; do
		case "$1" in
			--ssh-name|--ssh-host|--ssh-port|--ssh-user|--ssh-home|--ssh-args)
				DistroImageParseSshOptions "$1" "$2"; shift 2; continue
			;;
			--ssh-*)
				echo "$MDSC_CMD: â›” ERROR: invalid --ssh-XXXX option: $1" >&2
				set +e ; return 1
			;;
			*)
				break
			;;
		esac
	done

	local extraArguments="$@"

	if [ -z "$useSshHome" ] ; then
		useSshHome="$( echo ~/.ssh )"
	elif [ "$useSshHome" = "${useSshHome#'/'}" ] ; then
		useSshHome="$MMDAPP/source/${useSshHome#$MMDAPP/source/}"
	fi
	if [ -z "$useSshUser" ] ; then
		useSshUser="$( whoami )"
	fi

	eval "$(
		if true ; then
			if [ ! -d "$useSshHome" ] ; then
				echo "$MDSC_CMD: â›” ERROR: ssh home directory does not exist: $useSshHome" >&2
				set +e ; return 1
			fi
	
			[ -z "$MDSC_DETAIL" ] || echo "* $MDSC_CMD: client spec parsed: $useSshUser $useSshHome" >&2
			
			local sshConfig= x
			for x in "ssh_config" "config-dummy.txt"; do
				if [ -f "$useSshHome/$x" ]; then
					sshConfig="$useSshHome/$x"
					sshConfig=" -F $sshConfig"
					break
				fi
			done
			
			local sshSecret= x
			for x in "client.key" "id_ecdsa" "id_ed25519" "id_rsa" "client.rsa"; do
				if [ -f "$useSshHome/$x" ]; then
					sshSecret="$useSshHome/$x"
					if [ -O "$sshSecret" ] ; then
						chmod 600 "$sshSecret"
					fi
					sshSecret=" -o PreferredAuthentications=publickey -i $sshSecret"
					break
				fi
			done

			local sshHosts="$useSshHome/known_hosts" 
			if [ -f "$sshHosts" ] ; then
				sshHosts=" -o UserKnownHostsFile=$sshHosts"
			else
				sshHosts=
			fi
			
			[ full != "$MDSC_DETAIL" ] || echo "set -x"

			printf 'ssh %s -p %s -l %s %s %s %s %s %s\n' \
				"$useSshHost" \
				"$useSshPort" \
				"$useSshUser" \
				"$useSshArgs -o ConnectTimeout=10" \
				"$sshHosts" \
				"$sshConfig" \
				"$sshSecret" \
				"$extraArguments"
		fi \
		| sed -e 's|^ *||g' -e 's| *$||g' -e 's|  | |g'
	)"
	
}


#
#
DistroImagePrintSshTarget(){
	[ full != "$MDSC_DETAIL" ] || echo "+ DistroImagePrintSshTarget: $@" >&2
	local useSshHost="${useSshHost:-}" useSshPort="${useSshPort:-}" useSshUser="${useSshUser:-}" useSshHome=  useSshArgs=
	DistroImageParseSshOptions $@ 2>/dev/null
	printf '%s@%s:%s' "$useSshUser" "$useSshHost" "$useSshPort"
	return 0
}


#
#
DistroImageParseSshOptions(){
	[ -z "$MDSC_DETAIL" ] || echo "+ DistroImageParseSshOptions: $@" >&2
	while true ; do
		case "$1" in
			--ssh-name) # for prefix only, yet
				shift 2
			;;
			--ssh-host)
				useSshHost="$2" ; shift 2
			;;
			--ssh-port)
				useSshPort="$2" ; shift 2
			;;
			--ssh-user)
				useSshUser="$2" ; shift 2
			;;
			--ssh-home)
				useSshHome="${2#$MMDAPP/source/}" ; shift 2
			;;
			--ssh-args)
				useSshArgs="$2" ; shift 2
			;;
			*)
				return 0
			;;
		esac
	done
}

# prints ssh options as argument list (--ssh-host ...)
#
DistroImageProjectSshTargets(){
	local MDSC_CMD='DistroImageProjectSshTargets'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	. "$MDLT_ORIGIN/myx/myx.distro-system/sh-lib/SystemContext.UseStandardOptions.include"
	
	local MDSC_PRJ_NAME="${MDSC_PRJ_NAME:-}"

	local useSshHost="${useSshHost:-}" useSshPort="${useSshPort:-}" useSshUser="${useSshUser:-}" useSshHome="${useSshHome:-}" useSshArgs="${useSshArgs:-}"
	local linePrefix= lineSuffix=
	
	while true ; do
		case "$1" in
			--project)
				DistroSelectProject MDSC_PRJ_NAME "$2" ; shift 2
			;;
			*)
				break
			;;
		esac
	done

	if [ -z "$MDSC_PRJ_NAME" ] ; then
		echo "$MDSC_CMD: â›” ERROR: project is not selected!" >&2
		set +e ; return 1
	fi

	Distro ListDistroProvides --select-one-project "$MDSC_PRJ_NAME" \
		--filter-own-provides-column "deploy-ssh-target:" \
		--add-merged-provides-column "deploy-ssh-client-settings:" \
	| DistroImageExtractSshConnections "$@"
	return 0
}

DistroImageExtractSshConnections(){
	local MDSC_CMD='DistroImageExtractSshConnections'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	local useSshHost="${useSshHost:-}" useSshPort="${useSshPort:-}" useSshUser="${useSshUser:-}" useSshHome="${useSshHome:-}" useSshArgs="${useSshArgs:-}"
	local linePrefix= lineSuffix= noProjectColumn="${noProjectColumn:-}" noTargetColumn="${noTargetColumn:-}"

	while true ; do
		case "$1" in
			--ssh-name|--ssh-host|--ssh-port|--ssh-user|--ssh-home|--ssh-args)
				DistroImageParseSshOptions "$1" "$2"; shift 2; continue
			;;
			--no-target-column)
				noTargetColumn="$1" ; shift
			;;
			--no-project-column)
				noProjectColumn="$1" ; shift
			;;
			--line-prefix)
				linePrefix="$2" ; shift 2
			;;
			--line-suffix)
				lineSuffix="$2" ; shift 2
			;;
			*)
				break
			;;
		esac
	done

	local extraArguments="$*"

	local setSshHost="${useSshHost:-}" setSshPort="${useSshPort:-}" setSshUser="${useSshUser:-}" setSshHome="${useSshHome:-}" setSshArgs="${useSshArgs:-}"
	local sshName sshHost sshPort sshUser sshHome sshArgs sshSpec clientSpec
	
	awk '
		{
			n1 = split($2, a, "|")
			n2 = split($3, t, "|")
			args = ""
			for (i = 1; i <= n2; i++) {
				tok = t[i]
				gsub(/:/, " ", tok)
				args = ( args ? args " " tok : tok )
			}

			for (i = 1; i <= n1; i++) {
				print $1, a[i], args
			}
		}
	' \
	| while read -r projectName sshTarget sshOptions ; do
		[ -z "$MDSC_DETAIL" ] || echo "+ $MDSC_CMD: $sshTarget, options: $sshOptions" >&2

		sshSpec="$( echo "$sshTarget" | sed 's,^.*@,,' )"
		sshUser="${sshTarget%${sshTarget%@$sshSpec}}"
		sshName="$( echo "$sshSpec" | sed 's,:.*$,,' )"
		sshPort="$( echo "$sshSpec" | sed 's,^.*:,,' )"

		useSshHost="${setSshHost:-$sshName}"
		useSshPort="${setSshPort:-$sshPort}"
		useSshUser="${setSshUser:-$sshUser}"
		useSshHome="$setSshHome"
		useSshArgs="$setSshArgs"

		DistroImageParseSshOptions $sshOptions
		
		sshHost="${setSshHost:-$useSshHost}"
		sshPort="${setSshPort:-$useSshPort}"
		sshHome="${setSshHome:-$useSshHome}"
		sshUser="${setSshUser:-$useSshUser}"
		sshArgs="${setSshArgs:-$useSshArgs}"
		
		if [ -z "$sshHome" ]; then
			sshHome="$( echo ~/.ssh )"
		fi

		if [ -z "$noTargetColumn" ]; then
			sshTarget="$sshTarget "
		else
			sshTarget=
		fi
		if [ -z "$noProjectColumn" ]; then
			sshTarget="$projectName $sshTarget"
		fi

		if [ "$sshHost" != "$sshName" ] ; then
			printf '%s%s--ssh-name %q --ssh-host %q --ssh-port %q --ssh-user %q --ssh-home %q --ssh-args %q %s%s\n' \
				"$sshTarget" "$linePrefix" \
				"$sshName" "$sshHost" "$sshPort" "$sshUser" \
				"$sshHome" "$sshArgs" \
				"$extraArguments" "$lineSuffix"
			continue				
		fi

		printf '%s%s--ssh-host %q --ssh-port %q --ssh-user %q --ssh-home %q --ssh-args %q %s%s\n' \
			"$sshTarget" "$linePrefix" \
			"$sshHost" "$sshPort" "$sshUser" \
			"$sshHome" "$sshArgs" \
			"$extraArguments" "$lineSuffix"
		continue
	done \
	| sed -e 's|^ *||g' -e 's| *$||g' -e 's|  | |g'
}

# prints project merged provides
DistroImageProjectProvidesMerged(){
	local MDSC_CMD='DistroImageProjectProvidesMerged'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	if [ -z "$MDSC_PRJ_NAME" ] ; then
		echo "$MDSC_CMD: â›” ERROR: project is not selected!" >&2
		set +e ; return 1
	fi

	set -e
	DistroSystemContext --project-index-provides-merged "$MDSC_PRJ_NAME" \
	awk '{ out = $2 " " $3; if (!seen[out]++) print out }'
}

#
# call with --install|--prepare [--export|--local] argument
DistroImageProjectContextVariables(){
	local MDSC_CMD='DistroImageProjectContextVariables'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2
	if [ -z "$MDSC_PRJ_NAME" ] ; then
		echo "$MDSC_CMD: â›” ERROR: project is not selected!" >&2
		set +e ; return 1
	fi

	local prefix= filter=

	while true ; do 
		case "$1" in
			--install)
				shift
				filter="grep -e ' image-install:context-variable:'"
			;;
			--prepare)
				shift
				filter="grep -e ' image-prepare:context-variable:'"
			;;
			--export)
				prefix="export " ; shift
			;;
			--local)
				prefix="local " ; shift
			;;
			'')
				break
			;;
			*)
				echo "$MDSC_CMD: â›” ERROR: Invalid option: $1" >&2
				set +e ; return 1
			;;
		esac
	done

	local variableName operationType variableValue 
	local buildBuffer variableNames

	buildBuffer="`

		DistroImageProjectProvidesMerged \
		| eval $filter \
		| sed 's/:/ /; s/:/ /; s/:/ /; s/:/ /' | cut -d" " -f1,4- \
		| while read -r declaredAt variableName operationType variableValue ; do
			[ full !=  "$MDSC_DETAIL" ] || echo "$MDSC_CMD: input: $variableName $operationType $variableValue" >&2
			printf '\n## ## %s\n' "$variableName"
			case "$operationType" in
			
				# if variable is not defined - creates variable/array with given value 
				create)
					printf '[ -n "$VAR_%s" ] || VAR_%s=%q\n' \
						"$variableName" \
						"$variableName" "$variableValue"
				;;
				
				# if variable is defined - sets it's value to given one
				change)
					printf '[ -z "$VAR_%s" ] || VAR_%s=%q\n' \
						"$variableName" \
						"$variableName" "$variableValue"
				;;
				
				# if variable is not defined - creates array with given value 
				# if variable is defined - ensures array contains given value 
				ensure)
					printf	'[ -z "$VAR_%s" ] && VAR_%s="%q" || echo "$VAR_%s" | grep -q -x "%q" || VAR_%s="$VAR_%s\\n%q"\n' \
						"$variableName" \
						"$variableName" "$variableValue" \
						"$variableName" "$variableValue" \
						"$variableName" "$variableName" "$variableValue"
				;;
				
				# if variable is not defined - creates array with given value 
				# if variable is defined - appends given value to array regardless if it's already present 
				append|insert)
					printf	'[ -z "$VAR_%s" ] && VAR_%s="%q" || VAR_%s="$VAR_%s\\n%q"\n' \
						"$variableName" \
						"$variableName" "$variableValue" \
						"$variableName" "$variableName" "$variableValue"
				;;
				
				# if variable is defined - ensures array contains given value 
				update)
					printf	'[ -z "$VAR_%s" ] || VAR_%s="$( echo "$VAR_%s" | grep -x -v %q ; echo %q )"\n'\
						"$variableName" \
						"$variableName" "$variableName" "$variableValue" "$variableValue"
					continue
					
					printf	'[ -z "$VAR_%s" ] || VAR_%s="$( printf '%s\n%s' "$VAR_%s" %q )"\n'\
						"$variableName" \
						'%s' '%s' "$variableName" "$variableName" "$variableValue"
				;;
				
				# if variable is defined - removes given value from array. Un-defines variable if no value given.
				remove)
					if [ -z "$variableValue" ] ; then
						printf 'VAR_%s=\n' \
							"$variableName"
					else
						printf	'[ -z "$VAR_%s" ] || VAR_%s="$( echo "$VAR_%s" | grep -x -v %q )"\n' \
							"$variableName" \
							"$variableName" "$variableName" "$variableValue"
					fi
				;;

				# if variable is not defined - creates variable with given value 
				# if variable is defined - sets variable to given value (same) 
				re-set|define|upsert)
					printf 'VAR_%s=%q\n'\
						"$variableName" "$variableValue"
				;;

				# define from project relative file
				import|source)
					local variableValue=$( echo "$variableValue" | tr ':' ' ' \
					| while read -r sourceName sourcePath ; do
						[ -z "$MDSC_DETAIL" ] || echo "$MDSC_CMD: import: check: $declaredAt $sourceName $sourcePath" >&2
						DistroImageCheckSourcePath --file "$declaredAt" "$sourceName" "$sourcePath" \
						| cut -d" " -f2-
					done \
					| while read -r sourceName scriptFile ; do
						# [ -z "$MDSC_DETAIL" ] || echo "$MDSC_CMD: import: parse: $sourceName $scriptFile" >&2
						cat "$MMDAPP/source/$sourceName/$scriptFile"
					done )
					printf 'VAR_%s=%q\n'\
						"$variableName" "$variableValue"
				;;
				
				# Un-defines variable. Only when variable value matches, if variableValue specified.
				delete)
					if [ -z "$variableValue" ] ; then
						printf 'VAR_%s=\n' \
							"$variableName"
					else
						printf '[ "%s" != "$VAR_%s" ] || VAR_%s=\n' \
							"$variableValue" "$variableName" \
							"$variableName"
					fi
				;;
				
				*)
					echo "$MDSC_CMD: ðŸ™‹ WARNING: unknown context variable operation: $operationType:$variableName:$variableValue" >&2
				;;
			esac
		done

	`"
	
	if [ -z "${buildBuffer:0:1}" ] ; then
		return 0
	fi
	
	variableNames="$( 
		echo "$buildBuffer" | grep -e '^## ## ' | sed -e 's|^## ## ||g' | sort -u 
	)"
	
	buildBuffer="`
		for variableName in $variableNames ; do
			printf 'local VAR_%s\n' "$variableName"
		done
		echo "$buildBuffer"
		for variableName in $variableNames ; do
			printf 'printf %q %s "\$VAR_%s"\n' "$prefix%s=\\"%s\\"\n" "$variableName" "$variableName"
		done
	`"
	
	# hope for a new process
	( eval "$buildBuffer" ) </dev/null
	
	return 0
}

# echoes none/all matching deploy source folders or files
# arguments: --path/--file declaredAt sourceName sourcePath <extraArguments>
# output: declaredAt sourceName sourcePath <extraArguments>
DistroImageCheckSourcePath(){
	local MDSC_CMD='DistroImageCheckSourcePath'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	local MDSC_PRJ_NAME="${MDSC_PRJ_NAME:-}"

	while true ; do	
		case "$1" in
			--project)
				MDSC_PRJ_NAME="$2" ; shift 2 ; continue ;;
			--path)
				shift ;	local check="-d" ; continue ;;
			--file)
				shift ;	local check="-f" ; continue ;;
			*)
				break ;;
		esac
	done

	if [ -z "$MDSC_PRJ_NAME" ] ; then
		echo "$MDSC_CMD: â›” ERROR: project is not selected!" >&2
		set +e ; return 1
	fi
	
	local declaredAt="$1" sourceName="$2" sourcePath="$3"
	shift 3

	local checkProject commandOutput

	if [ -z "$sourceName" ] ; then
		echo "$MDSC_CMD: â›” ERROR: arguments missing" >&2
		set +e ; return 1
	fi

	if [ "$sourceName" = "*" -o "$sourceName" = "**" ] ; then
		commandOutput="$(
			while read -r checkProject ; do
				[ full != "$MDSC_DETAIL" ] || echo ">> $MDSC_CMD check wildcard path: " $check "$MDSC_SOURCE/$checkProject/$sourcePath" >&2
				if [ $check "$MDSC_SOURCE/$checkProject/$sourcePath" ] ; then
					if [ "$sourceName" = "**" ] || grep -q -x "$declaredAt" <( 
						DistroSystemContext --project-index-sequence "$checkProject"  awk '!x[$2]++ { print $2 }' 
					) ; then
						echo "$declaredAt" "$checkProject" "$sourcePath" "$@"
					fi
				fi
			done < <( DistroSystemContext --project-index-sequence "$MDSC_PRJ_NAME" awk '!x[$2]++ { print $2 }' )
		)"
	
		if [ -n "${commandOutput:0:1}" ] ; then
			echo "$commandOutput"
			return 0
		fi
		
		echo "$MDSC_CMD: ðŸ™‹ WARNING: wild-card path is not found: $declaredAt:$sourceName:$sourcePath" >&2
		set +e ; return 1
	fi
	
	if [ "$sourceName" = "." ] ; then
		sourceName="$declaredAt"
	fi
	
	if [ $check "$MDSC_SOURCE/$sourceName/$sourcePath" ] ; then
		[ full != "$MDSC_DETAIL" ] || echo ">> $MDSC_CMD found exact path: " $check "$MDSC_SOURCE/$sourceName/$sourcePath" >&2
		echo "$declaredAt" "$sourceName" "$sourcePath" "$@"
		return 0
	fi

	commandOutput="$(
		DistroSystemContext --index-provides \
		grep " $sourceName$" \
		| awk '$1 && !seen[$1]++ { print $1; }' \
		| while read -r checkProject ; do
			[ full != "$MDSC_DETAIL" ] || echo ">> $MDSC_CMD check exact path: " $check "$MDSC_SOURCE/$checkProject/$sourcePath" >&2
			if [ $check "$MDSC_SOURCE/$checkProject/$sourcePath" ] ; then
				[ full != "$MDSC_DETAIL" ] || echo ">> $MDSC_CMD found exact path in a loop: " $check "$MDSC_SOURCE/$checkProject/$sourcePath" >&2
				echo "$declaredAt" "$checkProject" "$sourcePath" "$@"
			fi
		done
	)"
	
	if [ -n "${commandOutput:0:1}" ] ; then
		echo "$commandOutput"
		return 0
	fi
	
	echo "$MDSC_CMD: ðŸ™‹ WARNING: explicitly declared path is not found: $declaredAt:$sourceName:$sourcePath" >&2
	set +e ; return 1
}

DistroImageEmbedScript(){ # "1-scriptFileName" "2-changeDir"
	local MDSC_CMD='DistroImageEmbedScript'
	[ -z "$MDSC_DETAIL" ] || echo "> $MDSC_CMD $(printf '%q ' "$@")" >&2

	if [ -z "$1" ] ; then
		echo "$MDSC_CMD: â›” ERROR: script file name argument is expected!" >&2
		set +e ; return 1
	fi
	if [ ! -f "$1" ] ; then
		echo "$MDSC_CMD: â›” ERROR: script file is does not exist: ${scriptFileName#$MMDAPP}" >&2
		set +e ; return 1
	fi
	if [ -z "$2" ] ; then
		echo "$MDSC_CMD: â›” ERROR: working directory argument is expected!" >&2
		set +e ; return 1
	fi
	
	[ -z "$MDSC_DETAIL" ] || echo "echo '> run: ${1#$MMDAPP}:$2' >&2"
	printf "\n\n# embedded script: %s\n\n( cd '%s' ; bash || echo '%s' >&2 ) << 'EOF_PROJECT_DIESSH_XXXXXXXX'\n" \
		"${1#$MMDAPP}" \
		"$2" \
		"ImageDeploy: â›” ERROR: script execution failed: $( basename "$1" )"
	cat "$1"
	printf '\nEOF_PROJECT_DIESSH_XXXXXXXX\n\n'
	[ -z "$MDSC_DETAIL" ] || echo "echo '< run: ${1#$MMDAPP}:$2' >&2"
	return 0
}

# main shell command
DistroImage(){
	echo "Not Supported!" >&2
	set +e ; return 1
}
